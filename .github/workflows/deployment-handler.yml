name: Deployment handler

on:
  workflow_call:
    inputs:
      cdk-role-arn:
        required: true
        type: string
      codeartifact-domain:
        required: false
        type: string
      codeartifact-domain-owner:
        required: false
        type: string
      codeartifact-namespace:
        required: false
        type: string
      codeartifact-region:
        required: false
        type: string
      codeartifact-repository:
        required: false
        type: string
      codeartifact-role-arn:
        required: false
        type: string
      cluster:
        required: false
        type: string
      deployment-id:
        required: false
        type: string
      deployment-target-name:
        required: true
        type: string
      ecr-account-id:
        required: false
        type: string
      ecr-region:
        required: false
        type: string
      ecr-role-arn:
        required: false
        type: string
      environment:
        required: true
        type: string
      namespace:
        required: true
        type: string
      region:
        required: true
        type: string
      stacks:
        required: false
        type: string
      task:
        required: true
        type: string
    secrets:
      ecr-repo-policy:
        required: false
      twingate-service-key:
        required: false

jobs:
  detect-files:
    runs-on: ubuntu-latest
    steps:
    - uses: actions/checkout@v3
    - id: detect-files
      run: |
        echo "::set-output name=cdk::$(find . -name cdk.json -exec dirname {} \; | jq -R -s -c 'split("\n")')"
        echo "::set-output name=docker::$(find . -name Dockerfile -exec dirname {} \; | jq -R -s -c 'split("\n")')"
        echo "::set-output name=helm::$(find . -name Chart.yaml -exec dirname {} \; | jq -R -s -c 'split("\n")')"
    outputs:
      cdk: ${{ steps.detect-files.outputs.cdk }}
      docker: ${{ steps.detect-files.outputs.docker }}
      helm: ${{ steps.detect-files.outputs.helm }}

  cdk-deploy:
    concurrency: cdk-${{ inputs.environment }}
    if: needs.detect-files.outputs.cdk != '[]'
    needs: detect-files
    permissions:
      contents: read
      id-token: write
    runs-on: ubuntu-latest
    strategy:
      matrix:
        path: ${{ needs.detect-files.outputs.cdk }}
    steps:
    - uses: byerobot/actions/cdk-deploy@main
      id: cdk-deploy
      with:
        codeartifact-domain: ${{ inputs.codeartifact-domain }}
        codeartifact-domain-owner: ${{ inputs.codeartifact-domain-owner }}
        codeartifact-namespace: ${{ inputs.codeartifact-namespace }}
        codeartifact-region: ${{ inputs.codeartifact-region }}
        codeartifact-repository: ${{ inputs.codeartifact-repository }}
        codeartifact-role-arn: ${{ inputs.codeartifact-role-arn }}
        env-vars: ACCOUNT_NAME=${{ inputs.deployment-target-name }},NAMESPACE=${{ inputs.namespace }}
        environment: ${{ inputs.environment }}
        cdk-region: ${{ inputs.region }}
        cdk-role-arn: ${{ inputs.cdk-role-arn }}
        path: ${{ matrix.path }}
        task: ${{ inputs.task }}
    outputs:
      url: ${{ steps.cdk-deploy.outputs.url }}

  ecr-build-push:
    if: needs.detect-files.outputs.docker != '[]' && inputs.task == 'deploy'
    needs: detect-files
    permissions:
      contents: read
      id-token: write
    concurrency: ${{ github.sha }}
    runs-on: ubuntu-latest
    strategy:
      matrix:
        path: ${{ needs.detect-files.outputs.docker }}
    steps:
    - uses: byerobot/actions/ecr-build-push@main
      with:
        codeartifact-domain: ${{ inputs.codeartifact-domain }}
        codeartifact-domain-owner: ${{ inputs.codeartifact-domain-owner }}
        codeartifact-namespace: ${{ inputs.codeartifact-namespace }}
        codeartifact-region: ${{ inputs.codeartifact-region }}
        codeartifact-repository: ${{ inputs.codeartifact-repository }}
        codeartifact-role-arn: ${{ inputs.codeartifact-role-arn }}
        ecr-region: ${{ inputs.ecr-region }}
        ecr-lifecycle-policy: |
          {
            "rules": [
              {
                "rulePriority": 2,
                "description": "expire untagged images over 5 days old",
                "selection": {
                  "tagStatus": "untagged",
                  "countType": "sinceImagePushed",
                  "countUnit": "days",
                  "countNumber": 5
                },
                "action": {
                  "type": "expire"
                }
              },
              {
                "rulePriority": 3,
                "description": "expire images when count exceeds 150",
                "selection": {
                  "tagStatus": "any",
                  "countType": "imageCountMoreThan",
                  "countNumber": 150
                },
                "action": {
                  "type": "expire"
                }
              }
            ]
          }
        ecr-repo-policy: ${{ secrets.ecr-repo-policy }}
        ecr-role-arn: ${{ inputs.ecr-role-arn }}
        path: ${{ matrix.path }}

  helm-package:
    if: needs.detect-files.outputs.helm != '[]' && inputs.task == 'deploy'
    needs: detect-files
    permissions:
      contents: read
      id-token: write
    runs-on: ubuntu-latest
    strategy:
      matrix:
        path: ${{ needs.detect-files.outputs.helm }}
    steps:
    - uses: byerobot/actions/helm-package@main
      with:
        ecr-account-id: ${{ inputs.ecr-account-id }}
        ecr-region: ${{ inputs.ecr-region }}
        ecr-role-arn: ${{ inputs.ecr-role-arn }}
        path: ${{ matrix.path }}

  eks-helm-deploy:
    # We have to use the ugly conditional below because we want this step to run on destroy,
    # even though the helm-package and ecr-build-push steps get skipped.
    if: |
      always() && 
      needs.detect-files.outputs.helm != '[]' &&
      (needs.ecr-build-push.result == 'success' || needs.ecr-build-push.result == 'skipped') &&
      (needs.helm-package.result == 'success' || needs.helm-package.result == 'skipped')
    concurrency: eks-helm-${{ inputs.environment }}
    needs:
    - detect-files
    - helm-package
    - ecr-build-push
    permissions:
      contents: read
      id-token: write
    runs-on: ubuntu-latest
    strategy:
      matrix:
        path: ${{ needs.detect-files.outputs.helm }}
    steps:
    - uses: byerobot/actions/eks-helm-deploy@main
      with:
        cluster: ${{ inputs.cluster }}
        environment: ${{ inputs.deployment-target-name }}
        namespace: ${{ inputs.namespace }}
        path: ${{ matrix.path }}
        region: ${{ inputs.region }}
        role-arn: ${{ inputs.cdk-role-arn }}
        task: ${{ inputs.task }}
        twingate-service-key: ${{ secrets.twingate-service-key }}

  update-deployment:
    needs:
    - cdk-deploy
    - eks-helm-deploy
    if: always()
    runs-on: ubuntu-latest
    permissions:
      deployments: write
    steps:
    - id: get-state
      run: |
        if [[ ${{ needs.cdk-deploy.result }} == 'skipped' ]] || [[ ${{ needs.cdk-deploy.result }} == 'success' ]]; then
          if [[ ${{ needs.eks-helm-deploy.result }} == 'skipped' ]] || [[ ${{ needs.eks-helm-deploy.result }} == 'success' ]]; then
            echo "::set-output name=state::success"
            exit 0
          fi
        fi
        echo "::set-output name=state::failure"
    - name: Update deployment status (deploy)
      if: inputs.task == 'deploy' && inputs.deployment-id != ''
      uses: chrnorm/deployment-status@v2
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        environment-url: ${{ needs.cdk-deploy.outputs.url }}
        state: ${{ steps.get-state.outputs.state }}
        deployment-id: ${{ inputs.deployment-id }}
    - name: Update deployment status (destroy)
      uses: strumwolf/delete-deployment-environment@v2
      if: inputs.task == 'destroy'
      with:
        token: ${{ secrets.GITHUB_TOKEN }}
        environment: ${{ inputs.environment }}
        onlyRemoveDeployments: true
    # TODO: Send notification on failed destroys?
